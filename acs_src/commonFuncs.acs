// A bunch of functions that I've built up
// They come in handy :>

#define PLAYERMAX 64
#define TEAMCOUNT 8
#define DEFAULTTID_SCRIPT 471
#define INTMAX 0x7FFFFFFF
#define INTMAXSAFE 0x7FFFFFFE

#define SECOND_TICS 35.714285714285715
#define UNIT_CM     2.73921568627451

#define BLINK_THRESHOLD (4 * 32)

function int itof(int x) { return x << 16; }
function int ftoi(int x) { return x >> 16; }

function int abs(int x)
{
	if (x < 0) { return -x; }
	return x;
}

function int sign(int x)
{
	if (x < 0) { return -1; }
	return 1;
}

function int randSign(void)
{
	return (2*random(0,1))-1;
}

function int pow(int x, int y)
{
	int n = 1;
	while (y-- > 0) { n *= x; }
	return n;
}

function int min(int x, int y)
{
	if (x < y) { return x; }
	return y;
}

function int max(int x, int y)
{
	if (x > y) { return x; }
	return y;
}

function int floorwhole(int fixedNumber)
{
	return fixedNumber & 0xFFFF0000;
}

/*function int floor(int fixedNumber)
{
	return fixedNumber & 0xFFFF0000;
}*/

function int middle(int x, int y, int z)
{
	if ((x < z) && (y < z)) { return max(x, y); }
	return max(min(x, y), z);
}

function int percFloat(int intg, int frac)
{
	return itof(intg) + (itof(frac) / 100);
}

function int percFloat2(int intg, int frac1, int frac2)
{
	return itof(intg) + (itof(frac1) / 100) + (itof(frac2) / 10000);
}

function int keyDown(int key)
{
	int buttons = GetPlayerInput(-1, INPUT_BUTTONS);

	if ((buttons & key) == key) { return 1; }
	return 0;
}

function int keyDown_any(int key)
{
	int buttons = GetPlayerInput(-1, INPUT_BUTTONS);

	if (buttons & key) { return 1; }
	return 0;
}

function int keysPressed(void)
{
	int buttons = GetPlayerInput(-1, INPUT_BUTTONS);
	int oldbuttons = GetPlayerInput(-1, INPUT_OLDBUTTONS);
	int newbuttons = (buttons ^ oldbuttons) & buttons;

	return newbuttons;
}

function int keyPressed(int key)
{
	if ((keysPressed() & key) == key) { return 1; }
	return 0;
}

function int keyPressed_any(int key)
{
	if (keysPressed() & key) { return 1; }
	return 0;
}

// Taken from http://zdoom.org/wiki/sqrt

function int sqrt_i(int number)
{
	if (number <= 3) { return number > 0; }

	int oldAns = number >> 1,                     // initial guess
	    newAns = (oldAns + number / oldAns) >> 1; // first iteration

	// main iterative method
	while (newAns < oldAns)
	{
		oldAns = newAns;
		newAns = (oldAns + number / oldAns) >> 1;
	}

	return oldAns;
}

function int oldsqrt(int number)
{
	if (number == 1.0) { return 1.0; }
	if (number <= 0) { return 0; }
	int val = 150.0;
	for (int i=0; i<15; i++) { val = (val + FixedDiv(number, val)) >> 1; }

	return val;
}

function int magnitudeTwo(int x, int y)
{
	return sqrt_i(x*x + y*y);
}

function int magnitudeTwo_f(int x, int y)
{
	return sqrt(FixedMul(x, x) + FixedMul(y, y));
}

function int magnitudeThree(int x, int y, int z)
{
	return sqrt_i(x*x + y*y + z*z);
}

function int magnitudeThree_f(int x, int y, int z)
{
	int len, ang;

	ang = VectorAngle(x, y);
	if (((ang + 0.125) % 0.5) > 0.25) { len = FixedDiv(y, sin(ang)); }
	else { len = FixedDiv(x, cos(ang)); }

	ang = VectorAngle(len, z);
	if (((ang + 0.125) % 0.5) > 0.25) { len = FixedDiv(z, sin(ang)); }
	else { len = FixedDiv(len, cos(ang)); }

	return len;
}

function int inRange(int low, int high, int x)
{
	return ((x >= low) && (x < high));
}

// This stuff only works with StrParam

function str cleanString(str string)
{
	int ret = "";
	int strSize = StrLen(string);

	int c, i;

	for (i = 0; i < strSize; i++)
	{
		c = GetChar(string, i);

		if ((c > 8 && c < 14) || (c > 31 && c < 127) || (c > 160 && c < 173))
		{
			ret = StrParam(s:ret, c:c);
		}
		else if (c == 28)
		{
			// Skip next character
			i += 1;
		}
	}

	return ret;
}

function str padStringR(str baseStr, str padChar, int len)
{
	int baseStrLen = StrLen(baseStr);

	if (baseStrLen >= len)
	{
		return baseStr;
	}

	padChar = GetChar(padChar, 0);
	str pad = "";
	int padLen = len - baseStrLen;
	int i;

	for (i = 0; i < padLen; i++)
	{
		pad = StrParam(s:pad, c:padChar);
	}

	return StrParam(s:baseStr, s:pad);
}

function str padStringL(str baseStr, str padChar, int len)
{
	int baseStrLen = StrLen(baseStr);

	if (baseStrLen >= len)
	{
		return baseStr;
	}

	padChar = GetChar(padChar, 0);
	str pad = "";
	int padLen = len - baseStrLen;
	int i;

	for (i = 0; i < padLen; i++)
	{
		pad = StrParam(s:pad, c:padChar);
	}

	return StrParam(s:pad, s:baseStr);
}

function str changeString(str string, str repl, int where)
{
	int len = StrLen(string);
	int rLen = StrLen(repl);

	if ((where + rLen < 0) || where >= len)
	{
		return string;
	}

	str ret = "";
	int i;

	for (i = 0; i < len; i++)
	{
		int c = inRange(where, where+rLen, i) ? GetChar(repl, i-where) : GetChar(string, i);

		ret = StrParam(s:ret, c:c);
	}

	return ret;
}

function str sliceString(str string, int start, int end)
{
	int len = StrLen(string);

	if (start < 0)
	{
		start = len + start;
	}

	if (end <= 0)
	{
		end = len + end;
	}

	start = max(0, start);
	end   = min(end, len-1);

	str ret = "";
	int i;

	for (i = start; i < end; i++)
	{
		ret = StrParam(s:ret, c:GetChar(string, i));
	}

	return ret;
}

// End StrParam

function int unusedTID(int start, int end)
{
	int ret = start - 1;
	int tidNum;

	if (start > end) { start ^= end; end ^= start; start ^= end; }  // good ol' XOR swap

	while (ret++ != end)
	{
		if (ThingCount(0, ret) == 0)
		{
			return ret;
		}
	}

	return -1;
}

function int getMaxHealth(int ignorestamina)
{
	int maxHP = GetActorProperty(0, APROP_SpawnHealth);

	if (maxHP == 0 && PlayerNumber() != -1)
	{
		maxHP = 100;
	}

	if (!ignorestamina) { maxHP += GetActorProperty(0, APROP_Stamina); }

	return maxHP;
}

function int giveHealthMax(int amount, int maxHP)
{
	int newHP;

	int curHP = GetActorProperty(0, APROP_Health);

	if (maxHP == 0) { newHP = max(curHP, curHP+amount); }
	else { newHP = middle(curHP, curHP+amount, maxHP); }

	SetActorProperty(0, APROP_Health, newHP);

	return newHP - curHP;
}

function bool isDead(int tid)
{
	return GetActorProperty(tid, APROP_Health) <= 0;
}

function bool isSinglePlayer(void)
{
	return GameType() == GAME_SINGLE_PLAYER;
}

function bool isLMS(void)
{
	return GetCVar("lastmanstanding") || GetCVar("teamlms");
}

function bool isCoop(void)
{
	bool check1 = GameType() == GAME_NET_COOPERATIVE;
	bool check2 = GetCVar("cooperative") || GetCVar("invasion") || GetCVar("survival");

	return check1 || check2;
}

function bool isDeathMatch(void)
{
	return GameType() == GAME_NET_DEATHMATCH;
}

function bool isInvasion(void)
{
	return GetCVar("invasion");
}

function bool isFreeForAll(void)
{
	if (GetCVar("terminator") || GetCVar("duel"))
	{
		return 1;
	}

	bool check1 = GetCVar("deathmatch") || GetCVar("possession") || GetCVar("lastmanstanding");
	bool check2 = check1 && !GetCVar("teamplay");

	return check2;
}

function bool isTeamGame(void)
{
	return GetCVar("teamplay") || GetCVar("teamgame") || GetCVar("teamlms");
}

function bool isCompetitiveGameMode(void)
{
	bool check1 = GameType() == GAME_NET_DEATHMATCH;
	bool check2 = GetCVar("deathmatch") || GetCVar("possession") || GetCVar("lastmanstanding") || GetCVar("terminator") || GetCVar("duel");
	bool check3 = GetCVar("teamplay") || GetCVar("teamgame") || GetCVar("teamlms");

	return check1 || check2 || check3;
}

function void SetInventory(str item, int amount)
{
	int count = CheckInventory(item);

	if (count < amount) { GiveInventory(item, amount - count); }

	// Another check here to account for sv_doubleammo giving double ammo
	int count2 = CheckInventory(item);

	if (count2 > amount) { TakeInventory(item, count2 - amount); }
}

function int cond(bool test, int trueRet, int falseRet)
{
	if (test) { return trueRet; }
	return falseRet;
}

#define DIR_E  1
#define DIR_NE 2
#define DIR_N  3
#define DIR_NW 4
#define DIR_W  5
#define DIR_SW 6
#define DIR_S  7
#define DIR_SE 8

function int getDirection(void)
{
	int sideMove = keyDown(BT_MOVERIGHT) - keyDown(BT_MOVELEFT);
	int forwMove = keyDown(BT_FORWARD) - keyDown(BT_BACK);

	if (sideMove || forwMove)
	{
		switch (sideMove)
		{
			case -1:
				switch (forwMove)
				{
					case -1: return DIR_SW;
					case  0: return DIR_W;
					case  1: return DIR_NW;
				}
				break;

			case 0:
				switch (forwMove)
				{
					case -1: return DIR_S;
					case  1: return DIR_N;
				}
				break;

			case 1:
				switch (forwMove)
				{
					case -1: return DIR_SE;
					case  0: return DIR_E;
					case  1: return DIR_NE;
				}
				break;
		}
	}

	return 0;
}

function bool isCrouching (int viewHeight)
{
	if (GetCVar("sv_nocrouch")) { return false; }

	return GetActorViewHeight(0) <= viewHeight;
}

function int defaultTID(int def)
{
	int tid = ActivatorTID();

	if (ThingCount(0, tid) == 1) { return tid; }

	tid = def;
	int i;
	if (def <= 0)
	{
		i = random(13, 23);
		tid = unusedTID(i*1000, (i+10)*1000);
	}

	Thing_ChangeTID(0, tid);
	ACS_NamedExecuteAlways("DefaultTIDScript", 0, tid,0,0);

	return tid;
}

script "DefaultTIDScript" (int tid) clientside //471 -- DEFAULTTID_SCRIPT
{
	if (ConsolePlayerNumber() == -1) { terminate; }
	Thing_ChangeTID(0, tid);
}

function int JumpZFromHeight(int height, int gravFactor)
{
	return oldsqrt(2 * height * gravFactor);
}

function int fround(int fixedNumber)
{
	return floorwhole((fixedNumber & 0xFFFF0000) + 0.5);
}

function int roundZandronum(int toround)
{
	return ftoi(toround + 0.5);
}

function int ceilZandronum(int toround)
{
	return ftoi(toround + (1.0-1));
}

function int distance_ftoi(int x1, int y1, int z1, int x2, int y2, int z2)
{
	return magnitudeThree(ftoi(x2-x1), ftoi(y2-y1), ftoi(z2-z1));
}

function void printDebugInfo(void)
{
	int classify = ClassifyActor(0);
	int pln = PlayerNumber();

	Log(s:" -- DEBUG INFO -- ");

	Log(s:"Executed on tic ", d:Timer(), s:" on map \"", n:PRINTNAME_LEVEL, s:"\"");

	if (classify & (ACTOR_PLAYER | ACTOR_MONSTER))
	{
		Log(s:"Script activator has ", d:GetActorProperty(0, APROP_Health), s:"/", d:getMaxHealth(0), s:" HP");
	}

	if (classify & ACTOR_PLAYER)
	{
		Log(s:"Is player ", d:pln, s:" (", n:0, s:"\c-) with class number ", d:PlayerClass(pln));
	}

	Log(s:" -- END DEBUG -- ");
}

function int PlayerTeamCount(int teamNo)
{
	int i, ret;
	for (i = 0; i < PLAYERMAX; i++)
	{
		if (GetPlayerInfo(i, PLAYERINFO_TEAM) == teamNO) { ret++; }
	}
	return ret;
}

function int RemoveMessages(int rangemin, int rangemax)
{
	for(int a = rangemin; a <= rangemax; a++)
		HudMessage(s:""; HUDMSG_PLAIN, a, CR_UNTRANSLATED, 0.0, 0.0, 1.0);

	return 0;
}

function int getaspectratio(void)
{
	int width = GetScreenWidth();
	int height = GetScreenHeight();
	int aspect = GetCVar("vid_aspect");
	switch(aspect)
	{
		case 1: return (16.0 / 9);
		case 2: return 1.6;
		case 3: return (4.0 / 3);
		case 4: return 1.25;
		case 5: return 1.7;
		case 6: return 7.0/3;
	}
	return abs(width<<16)/abs(height);
}

function int SetPointerExt(int assign_slot, int tid, int assign_to_tid)
{
	if (tid != 0)
	{
		SetActivator(tid); // Set activator to provided tid
	}

	int actTid = ActivatorTID(); // Get original activator tid if there is an activator (I have ASSUMED that it returns 0 if there is no activator)
	Thing_ChangeTID(0, UniqueTID()); // Create temporary, unique activator tid
	int temp = ActivatorTID(); // Get temporary activator tid (0 if there is no activator)
	int result = 0;

	if(SetActivator(assign_to_tid))
	{
		result = SetPointer(assign_slot, temp); // If an activator (assign_to_tid) is set, assign a pointer value to it
	}
	if(SetActivator(temp))
	{
		Thing_ChangeTID(0, actTid); // If an activator (temp) is set, restore its original tid (actTid)
	}

	return result;
}

function int AToI(str s)
{
   str a = "";
   int i, i2, n;
   int l = StrLen(s);
   for (i = 0; i < l; i++)
   {
	  for (i2 = 0; i2 < 10; i2++)
	  {
		 a = StrParam(i:i2);
		 if (!StrCmp(StrParam(c:GetChar(s, i)), a))
			n += i2 * pow(10, l - i - 1);
	  }
   }
   return n;
}

function int onLiquid(int tid)
{
	str floorTexture = GetActorFloorTexture(tid);

	//Water
	if(floorTexture=="FWATER1"||floorTexture=="FWATER2"||floorTexture=="FWATER3"||floorTexture=="FWATER4"
	||floorTexture=="X_005"||floorTexture=="FLTWAWA1"||floorTexture=="FLTWAWA2"||floorTexture=="FLTWAWA3"
	||floorTexture=="FLTFLWW1"||floorTexture=="FLTFLWW2"||floorTexture=="FLTFLWW3"||floorTexture=="F_HWATR1"
	||floorTexture=="F_HWATR2"||floorTexture=="F_HWATR3"||floorTexture=="F_VWATR1"||floorTexture=="F_VWATR2"
	||floorTexture=="F_VWATR3"||floorTexture=="F_WATR01"||floorTexture=="F_WATR02"||floorTexture=="F_WATR03")
	{
		return 1;
	}
	else if(floorTexture=="X_001"||floorTexture=="FLATHUH1"||floorTexture=="FLATHUH2"||floorTexture=="FLATHUH3"
	||floorTexture=="FLATHUH4"||floorTexture=="LAVA1"||floorTexture=="LAVA2"||floorTexture=="LAVA3"||floorTexture=="LAVA4")
	{
		return 2;
	}
	else if(floorTexture=="NUKAGE1"||floorTexture=="NUKAGE2"||floorTexture=="NUKAGE3"||floorTexture=="X_009"
	||floorTexture=="FLTSLUD1"||floorTexture=="SLIME01"||floorTexture=="SLIME02"||floorTexture=="SLIME03"
	||floorTexture=="SLIME04"||floorTexture=="SLIME05"||floorTexture=="SLIME06"||floorTexture=="SLIME07"
	||floorTexture=="SLIME08"||floorTexture=="F_PWATR1"||floorTexture=="F_PWATR2"||floorTexture=="F_PWATR2")
	{
		return 3;
	}

	return 0;
}

function int returnLaserOrigin(int xyz, int horizontalOffset, int verticalOffset, int angle, int pitch)
{
	switch (xyz)
	{
		case 0: return FixedMul(sin(angle),horizontalOffset);
		case 1: return FixedMul(cos(angle),horizontalOffset);
		case 2: return verticalOffset;
	}

	return 0;
}

function bool isPlayerOrBot(int tid)
{
	int actorClass = ClassifyActor(tid);

	return (actorClass & ACTOR_PLAYER) || (actorClass & ACTOR_BOT);
}

script "IsThisSky" (int actortid)
{
	if(CheckActorCeilingTexture(actortid, "F_SKY1") || CheckActorCeilingTexture(actortid, "F_SKY2") || CheckActorCeilingTexture(actortid, "F_SKY") || CheckActorCeilingTexture(actortid, "F_SKY001") || CheckActorFloorTexture(actortid, "F_SKY1") || CheckActorFloorTexture(actortid, "F_SKY2") || CheckActorFloorTexture(actortid, "F_SKY") || CheckActorFloorTexture(actortid, "F_SKY001"))
		SetResultValue(1);
	else
		SetResultValue(0);
}

function int GetFirstPlayerCoords(int xyz)
{
	SetActivator(0,AAPTR_Player1);
	switch (xyz)
	{
		case 0: return GetActorX(0);
		case 1: return GetActorY(0);
		case 2: return GetActorZ(0);
	}
	return 0;
}

function int SpawnMissileEffect(str effectClassname, int effectTid)
{
	int missileTid = UniqueTID();

	SpawnForced(effectClassname, GetActorX(0), GetActorY(0), GetActorZ(0), effectTid);

	Thing_ChangeTID(0, missileTid);

	SetActivator(effectTid);
	SetPointer(AAPTR_TARGET, missileTid, AAPTR_TARGET);

	return missileTid;
}

script "wrongClient" (int player) clientside
{
	SetResultValue(player != ConsolePlayerNumber());
}

script "getPointerAngle" (int myTid, int pointer)
{
	if(pointer == 0) pointer = AAPTR_Target;
	SetActivator(myTid,pointer);
	SetResultValue(GetActorAngle(myTid));
}

script "getPointerPitch" (int myTid, int pointer)
{
	if(pointer == 0) pointer = AAPTR_Target;
	SetActivator(myTid,pointer);
	SetResultValue(GetActorPitch(myTid));
}

script "getTargetX" (int myTid, int pointer)
{
	if(pointer == 0) pointer = AAPTR_Target;
	SetActivator(myTid,pointer);
	SetResultValue(GetActorX(myTid));
}

script "getTargetY" (int myTid, int pointer)
{
	if(pointer == 0) pointer = AAPTR_Target;
	SetActivator(myTid,pointer);
	SetResultValue(GetActorY(myTid));
}

script "getTargetZ" (int myTid, int pointer)
{
	if(pointer == 0) pointer = AAPTR_Target;
	SetActivator(myTid,pointer);
	SetResultValue(GetActorZ(myTid));
}

script "hasValidPointer" (int myTid, int pointer)
{
	SetResultValue(SetActivator(myTid,pointer));
}

script "screenBlocks" (void) clientside
{
	SetResultValue(GetCvar("screenblocks"));
}

/*HUD Library by Shiny Metagross
if HUDMSG_TYPEON:
inTime = typeTime
outTime = outTime
if HUDMSG_FADEOUT:
inTime = fadeTime
*/

function void HudMessageEx(int font, int message, int sizeX, int sizeY, int flags, int id, int color, int x, int y, int flagx, int flagy, int holdTime, int inTime, int outTime, int alpha, int statusbar)
{
	if(strlen(font) > 0) SetFont(font);
	if(sizeX != 0 && sizeY != 0) SetHudSize((320*sizeX)>>16,(200*sizeY)>>16,statusbar);
	int posX = FixedMul((320*sizeX)>>16,x);
	int posY = FixedMul((200*sizeY)>>16,y);
	if(flags & HUDMSG_FADEOUT) HudMessage(s:message; flags, id, color, (posX*1.0)+flagx, (posY*1.0)+flagy, holdTime, inTime, alpha);
	else if(flags & HUDMSG_TYPEON || flags & HUDMSG_FADEINOUT) HudMessage(s:message; flags, id, color, (posX*1.0)+flagx, (posY*1.0)+flagy, holdTime, inTime, outTime, alpha);
	else HudMessage(s:message; flags, id, color, (posX*1.0)+flagx, (posY*1.0)+flagy, holdTime, alpha);
}

// [tv50] GetTimeProperty is a new function in Zandronum that is treated as a dummy
// [tv50] in ZDoom, returning 0 there (as opposed to 1970 in Zandronum with the
// [tv50] parameters chosen). Compared to previous methods, no side effects have
// [tv50] come from this, so this should be used for checking the current source port.

function bool isZDoom (void) { return GetTimeProperty(0, 5, true) == 0; } // TM_YEAR = 5

function void SetPlayerActivator (int pln)
{
	if (!isZDoom()) { SetActivatorToPlayer(pln); }
	else { SetActivator(0, AAPTR_PLAYER1 << pln); }
}

function int relativeAngleToXY(int sourceTid, int targetX, int targetY)
{
	int sourceAngle = GetActorAngle(sourceTid);
	int sourceX = GetActorX(sourceTid);
	int sourceY = GetActorY(sourceTid);

	int vang = VectorAngle(sourceX - targetX, sourceY - targetY);
	int vangClamped = vang % 1.0;

	return sourceAngle - vangClamped;
}
